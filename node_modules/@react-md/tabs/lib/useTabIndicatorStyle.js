"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = require("react");
var utils_1 = require("@react-md/utils");
var TAB_WIDTH_VAR = "--rmd-tab-width";
var TAB_OFFSET_VAR = "--rmd-tab-offset";
var getActiveTab = function (itemRefs, activeIndex) {
    return (itemRefs[activeIndex] && itemRefs[activeIndex].current) || null;
};
/**
 * This hook will merge the provided style object along with the required css
 * variables for the active tab underline moving to the correct location. The
 * indicator will be updated to be the same width as the tab along with offset
 * by all the tabs' sizes.
 *
 * @private
 */
function useTabIndicatorStyle(_a) {
    var style = _a.style, ref = _a.ref, align = _a.align, itemRefs = _a.itemRefs, totalTabs = _a.totalTabs, activeIndex = _a.activeIndex;
    var _b = react_1.useState(function () {
        var _a;
        var tabWidth = 100 / totalTabs + "%";
        return _a = {},
            _a[TAB_WIDTH_VAR] = tabWidth,
            _a[TAB_OFFSET_VAR] = "calc(" + activeIndex + " * " + tabWidth + ")",
            _a;
    }), cssVars = _b[0], setCSSVars = _b[1];
    var prevCSSVars = react_1.useRef(cssVars);
    var updateCSSVars = react_1.useCallback(function (itemRefs, activeIndex) {
        var _a;
        var activeTab = getActiveTab(itemRefs, activeIndex);
        if (!activeTab) {
            return;
        }
        var nextCSSVars = (_a = {},
            _a[TAB_WIDTH_VAR] = activeTab.offsetWidth + "px",
            _a[TAB_OFFSET_VAR] = activeTab.offsetLeft + "px",
            _a);
        var cssVars = prevCSSVars.current;
        if (cssVars[TAB_WIDTH_VAR] !== nextCSSVars[TAB_WIDTH_VAR] ||
            cssVars[TAB_OFFSET_VAR] !== nextCSSVars[TAB_OFFSET_VAR]) {
            prevCSSVars.current = nextCSSVars;
            setCSSVars(nextCSSVars);
        }
    }, []);
    react_1.useEffect(function () {
        updateCSSVars(itemRefs, activeIndex);
        // has to also be triggered for align changes since the indicator offset
        // will be incorrect for that.
    }, [activeIndex, itemRefs, updateCSSVars, align]);
    var tabsRef = react_1.useRef(null);
    var mergedRef = react_1.useCallback(function (instance) {
        utils_1.applyRef(instance, ref);
        tabsRef.current = instance;
    }, [ref]);
    utils_1.useResizeObserver({
        target: tabsRef,
        onResize: function () {
            // whenever the tabs container element is resized, it _probably_ means
            // that the tabs will be resized or moved. this means the indicator will
            // be in the wrong place so we need to fix it here.
            updateCSSVars(itemRefs, activeIndex);
        },
    });
    // TODO: Look into removing this resize observer. This is only required if
    // someone manually updates the width of the tab (dev utils) or if the width
    // was not changed due to the tabs container element resizing (iffy)
    utils_1.useResizeObserver({
        target: function () { return getActiveTab(itemRefs, activeIndex); },
        onResize: function () {
            updateCSSVars(itemRefs, activeIndex);
        },
    });
    var mergedStyle = react_1.useMemo(function () { return (__assign(__assign({}, style), cssVars)); }, [
        style,
        cssVars,
    ]);
    return [mergedStyle, mergedRef, tabsRef];
}
exports.default = useTabIndicatorStyle;
//# sourceMappingURL=useTabIndicatorStyle.js.map