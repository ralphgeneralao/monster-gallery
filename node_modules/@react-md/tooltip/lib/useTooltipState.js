"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useOtherInteractionDisable = void 0;
var react_1 = require("react");
var utils_1 = require("@react-md/utils");
var constants_1 = require("./constants");
var useHandlers_1 = require("./useHandlers");
var usePosition_1 = __importDefault(require("./usePosition"));
var useVisibilityChange_1 = __importDefault(require("./useVisibilityChange"));
/**
 * When the tooltip becomes visible, the tooltip should be hidden if any element
 * within the page is clicked, or the browser is blurred. This hook will just
 * add the required event listeners to hide the tooltip.
 *
 * Whent he entire window is blurred, we start a different flow to ensure that a
 * tooltip won't appear when the window is re-focused. Without this flow, a
 * keyboard user that had focused a tooltippable element will have the tooltip
 * appear again after `x`ms which is not wanted. The user will need to manually
 * re-focus the tooltippable element to show a tooltip again.
 */
function useOtherInteractionDisable(initiated, hideTooltip) {
    react_1.useEffect(function () {
        if (!initiated) {
            return;
        }
        window.addEventListener("mousedown", hideTooltip, true);
        window.addEventListener("click", hideTooltip, true);
        return function () {
            window.removeEventListener("mousedown", hideTooltip, true);
            window.removeEventListener("click", hideTooltip, true);
        };
    }, [initiated, hideTooltip]);
}
exports.useOtherInteractionDisable = useOtherInteractionDisable;
/**
 * This is a reusable hook that allows you to have all the event listeners and
 * visibility logic of toolips so it can be used for any component. This is
 * extremely helpful for when you want to create more complex tooltips (like
 * dialogs).
 *
 * The tooltip state flow is pretty complex, so here's a quick run down of some
 * of the logic:
 * - the tooltip can only be shown by mouse, keyboard, or touch and can only be
 *   closed by the same "initiation" type. So basically if the tooltip was shown
 *   via mouse, it can only be closed by mouse as well.
 * - if the user resizes the window, scrolls the page, clicks anywhere on the
 *   page, switches tabs/ blurs the browser window while the tooltip is visible,
 *   the tooltip will be hidden.
 * - a keyboard user can hide the tooltip by pressing the escape key after it
 *   was shown by focusing the element
 *
 * Since the tooltip can appear above or below the element, the position of the
 * tooltip must be determined before the tooltip becomes visible or else the
 * animation will be in the wrong direction.  So when one of the starting
 * interaction types happen to the container element, the initial position is
 * "guessed" based on the current viewport height and the position of the
 * container element within the viewport.
 */
function useTooltipState(_a) {
    var propPosition = _a.position, defaultPosition = _a.defaultPosition, _b = _a.positionThreshold, positionThreshold = _b === void 0 ? constants_1.DEFAULT_TOOLTIP_THRESHOLD : _b, _c = _a.hoverDelay, hoverDelay = _c === void 0 ? constants_1.DEFAULT_TOOLTIP_DELAY : _c, _d = _a.touchTimeout, touchTimeout = _d === void 0 ? constants_1.DEFAULT_TOOLTIP_DELAY : _d, _e = _a.focusDelay, focusDelay = _e === void 0 ? constants_1.DEFAULT_TOOLTIP_DELAY : _e, disableHoverMode = _a.disableHoverMode, onMouseEnter = _a.onMouseEnter, onMouseLeave = _a.onMouseLeave, onTouchStart = _a.onTouchStart, onTouchMove = _a.onTouchMove, onFocus = _a.onFocus, onBlur = _a.onBlur, onKeyDown = _a.onKeyDown, onShow = _a.onShow, onHide = _a.onHide;
    var mode = utils_1.useUserInteractionMode();
    var initiated = react_1.useRef(null);
    var setInitiated = react_1.useCallback(function (initiatedBy) {
        initiated.current = initiatedBy;
    }, []);
    var _f = utils_1.useToggle(false), visible = _f[0], showTooltip = _f[1], hide = _f[2];
    var hideTooltip = react_1.useCallback(function () {
        initiated.current = null;
        hide();
    }, [hide]);
    useVisibilityChange_1.default({
        visible: visible,
        onShow: onShow,
        onHide: onHide,
        mode: initiated.current,
    });
    var _g = usePosition_1.default({
        position: propPosition,
        defaultPosition: defaultPosition,
        threshold: positionThreshold,
    }), position = _g.position, setEstimatedPosition = _g.setEstimatedPosition;
    var _h = useHandlers_1.useMouseState({
        mode: mode,
        showTooltip: showTooltip,
        hideTooltip: hideTooltip,
        delay: hoverDelay,
        disableHoverMode: disableHoverMode,
        initiated: initiated,
        setInitiated: setInitiated,
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
        setEstimatedPosition: setEstimatedPosition,
    }), stopMouseTimer = _h[0], handleMouseEnter = _h[1], handleMouseLeave = _h[2];
    var _j = useHandlers_1.useKeyboardState({
        mode: mode,
        showTooltip: showTooltip,
        hideTooltip: hideTooltip,
        delay: focusDelay,
        initiated: initiated,
        setInitiated: setInitiated,
        onFocus: onFocus,
        onBlur: onBlur,
        onKeyDown: onKeyDown,
        setEstimatedPosition: setEstimatedPosition,
    }), stopKeyboardTimer = _j[0], handleFocus = _j[1], handleBlur = _j[2], handleKeyDown = _j[3];
    var _k = useHandlers_1.useTouchState({
        mode: mode,
        visible: visible,
        showTooltip: showTooltip,
        hideTooltip: hideTooltip,
        delay: touchTimeout,
        initiated: initiated,
        setInitiated: setInitiated,
        onTouchStart: onTouchStart,
        onTouchMove: onTouchMove,
        setEstimatedPosition: setEstimatedPosition,
    }), stopTouchTimer = _k[0], handleTouchStart = _k[1], handleTouchMove = _k[2], handleContextMenu = _k[3];
    var hideAndReset = react_1.useCallback(function () {
        stopMouseTimer();
        stopKeyboardTimer();
        stopTouchTimer();
        hide();
    }, [stopMouseTimer, stopKeyboardTimer, stopTouchTimer, hide]);
    useOtherInteractionDisable(initiated.current, hideAndReset);
    return {
        hide: hide,
        visible: visible,
        position: position,
        handlers: {
            onMouseEnter: handleMouseEnter,
            onMouseLeave: handleMouseLeave,
            onFocus: handleFocus,
            onBlur: handleBlur,
            onKeyDown: handleKeyDown,
            onTouchStart: handleTouchStart,
            onTouchMove: handleTouchMove,
            onContextMenu: handleContextMenu,
        },
    };
}
exports.default = useTooltipState;
//# sourceMappingURL=useTooltipState.js.map