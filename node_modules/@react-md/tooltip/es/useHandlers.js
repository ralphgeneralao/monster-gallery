import { useCallback, useEffect, useRef, } from "react";
import { useRefCache, useTimeout } from "@react-md/utils";
import { useTooltipHoverModeActions, useTooltipHoverModeDelay, useTooltipHoverModeEnabled, } from "./useTooltipHoverMode";
/**
 * This handles creating and returning the required mouse event listeners to
 * show and hide tooltips as needed. If there were any mouse event listeners
 * passed in, they will be merged with the tooltip logic automatically and
 * memoized.
 */
export function useMouseState(_a) {
    var mode = _a.mode, showTooltip = _a.showTooltip, hideTooltip = _a.hideTooltip, initiated = _a.initiated, setInitiated = _a.setInitiated, propDelay = _a.delay, onMouseEnter = _a.onMouseEnter, onMouseLeave = _a.onMouseLeave, setEstimatedPosition = _a.setEstimatedPosition, disableHoverMode = _a.disableHoverMode;
    var handlers = useRefCache({ onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave });
    var isHoverModeable = useTooltipHoverModeEnabled();
    if (typeof disableHoverMode === "boolean") {
        isHoverModeable = !disableHoverMode;
    }
    var delay = useTooltipHoverModeDelay();
    if (!isHoverModeable) {
        delay = propDelay;
    }
    var hoverModeActions = useTooltipHoverModeActions();
    var _b = useTimeout(function () {
        if (initiated.current === "mouse") {
            showTooltip();
            if (isHoverModeable) {
                hoverModeActions.enable();
            }
        }
    }, delay), start = _b[0], stop = _b[1];
    var handleMouseEnter = useCallback(function (event) {
        var onMouseEnter = handlers.current.onMouseEnter;
        if (onMouseEnter) {
            onMouseEnter(event);
        }
        if (initiated.current !== null) {
            return;
        }
        setInitiated("mouse");
        setEstimatedPosition(event.currentTarget);
        start();
    }, [setEstimatedPosition, setInitiated, start, handlers, initiated]);
    var handleMouseLeave = useCallback(function (event) {
        var onMouseLeave = handlers.current.onMouseLeave;
        if (onMouseLeave) {
            onMouseLeave(event);
        }
        if (initiated.current !== "mouse") {
            return;
        }
        stop();
        hideTooltip();
        if (isHoverModeable) {
            hoverModeActions.startDisableTimer();
        }
    }, [isHoverModeable, handlers, hideTooltip, hoverModeActions, initiated, stop]);
    return [
        stop,
        mode !== "touch" ? handleMouseEnter : onMouseEnter,
        mode !== "touch" ? handleMouseLeave : onMouseLeave,
    ];
}
/**
 * This handles creating and returning the required keyboard event listeners to
 * show and hide tooltips as needed. If there were any keyboard event listeners
 * passed in, they will be merged with the tooltip logic automatically and
 * memoized.
 */
export function useKeyboardState(_a) {
    var mode = _a.mode, showTooltip = _a.showTooltip, hideTooltip = _a.hideTooltip, delay = _a.delay, initiated = _a.initiated, setInitiated = _a.setInitiated, onFocus = _a.onFocus, onBlur = _a.onBlur, onKeyDown = _a.onKeyDown, setEstimatedPosition = _a.setEstimatedPosition;
    var handlers = useRefCache({ onFocus: onFocus, onBlur: onBlur, onKeyDown: onKeyDown });
    var isWindowBlurred = useRef(false);
    var _b = useTimeout(function () {
        if (initiated.current === "keyboard") {
            showTooltip();
        }
    }, delay), start = _b[0], stop = _b[1];
    var handleFocus = useCallback(function (event) {
        var onFocus = handlers.current.onFocus;
        if (onFocus) {
            onFocus(event);
        }
        // if the entire browser window was blurred, we don't want to show the
        // tooltip on the next focus event since it is confusing to see a tooltip
        // appear again after re-focusing a window.
        if (isWindowBlurred.current) {
            isWindowBlurred.current = false;
            return;
        }
        setInitiated("keyboard");
        setEstimatedPosition(event.currentTarget);
        start();
    }, 
    // disabled since useRefCache for handlers
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [setEstimatedPosition, setInitiated, start]);
    var handleBlur = useCallback(function (event) {
        var onBlur = handlers.current.onBlur;
        if (onBlur) {
            onBlur(event);
        }
        stop();
        hideTooltip();
    }, 
    // disabled since useRefCache for handlers
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [hideTooltip, stop]);
    var handleKeyDown = useCallback(function (event) {
        var onKeyDown = handlers.current.onKeyDown;
        if (onKeyDown) {
            onKeyDown(event);
        }
        if (initiated.current === "keyboard" && event.key === "Escape") {
            stop();
            hideTooltip();
        }
    }, 
    // disabled since both initiated and handlers are refs
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [hideTooltip, stop]);
    useEffect(function () {
        if (mode !== "keyboard") {
            return;
        }
        // whenever the browser loses focus, need to ensure that when the browser is
        // re-focused the last focused element (that had a tooltip) does not make
        // the tooltip appear
        var handleWindowBlur = function () {
            if (document.hidden) {
                isWindowBlurred.current = true;
                hideTooltip();
            }
            else {
                window.requestAnimationFrame(function () {
                    isWindowBlurred.current = false;
                });
            }
        };
        window.addEventListener("visibilitychange", handleWindowBlur);
        return function () {
            window.removeEventListener("visibilitychange", handleWindowBlur);
        };
    }, [mode, hideTooltip]);
    return [
        stop,
        mode === "keyboard" ? handleFocus : onFocus,
        mode === "keyboard" ? handleBlur : onBlur,
        mode === "keyboard" ? handleKeyDown : onKeyDown,
    ];
}
/**
 * This handles creating and returning the required touch event listeners to
 * show and hide tooltips as needed. If there were any touch event listeners
 * passed in, they will be merged with the tooltip logic automatically and
 * memoized.
 *
 * Tooltips on touch devices are a bit different than mouse and keyboard. Since
 * tooltips appear after a long press on mobile and long presses on mobile cause
 * a context menu to appear, no timeouts for showing the tooltip are started
 * after a touchstart event.  The tooltip will only appear after a contextmenu
 * event which has the default behavior prevented so the tooltip appears
 * instead. After the tooltip appears, it will stay visible as long as the user
 * keeps their finger on their phone. Once they remove their finger, the tooltip
 * will be visible for another `x`ms to make it easier to read without their
 * finger in the way and finally hide.
 */
export function useTouchState(_a) {
    var mode = _a.mode, visible = _a.visible, showTooltip = _a.showTooltip, hideTooltip = _a.hideTooltip, delay = _a.delay, setInitiated = _a.setInitiated, onTouchStart = _a.onTouchStart, onTouchMove = _a.onTouchMove, onContextMenu = _a.onContextMenu, setEstimatedPosition = _a.setEstimatedPosition;
    var touched = useRef(false);
    var handlers = useRefCache({ onTouchStart: onTouchStart, onTouchMove: onTouchMove, onContextMenu: onContextMenu });
    var _b = useTimeout(function () {
        touched.current = false;
        hideTooltip();
    }, delay), start = _b[0], stop = _b[1];
    useEffect(function () {
        if (!visible) {
            return;
        }
        if (mode !== "touch") {
            touched.current = false;
            return;
        }
        var cb = function () {
            start();
            window.removeEventListener("touchend", cb, true);
        };
        window.addEventListener("touchend", cb, true);
        return function () {
            window.removeEventListener("touchend", cb, true);
        };
        // disabled since it should only be updated on visible or touch changes
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [visible, mode]);
    var handleTouchStart = useCallback(function (event) {
        var onTouchStart = handlers.current.onTouchStart;
        if (onTouchStart) {
            onTouchStart(event);
        }
        touched.current = true;
        stop();
        setEstimatedPosition(event.currentTarget);
    }, 
    // disabled since useRefCache for handlers
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [setEstimatedPosition, stop]);
    var handleTouchMove = useCallback(function (event) {
        var onTouchMove = handlers.current.onTouchMove;
        if (onTouchMove) {
            onTouchMove(event);
        }
        touched.current = false;
    }, 
    // disabled since useRefCache for handlers
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []);
    var handleContextMenu = useCallback(function (event) {
        var onContextMenu = handlers.current.onContextMenu;
        if (onContextMenu) {
            onContextMenu(event);
        }
        if (!touched.current) {
            return;
        }
        // need to prevent the context menu from appearing and instead show the tooltip
        event.preventDefault();
        // since the context menu might also select text by default, we want to deselect any
        // selected text if it is within the container element
        var selection = window.getSelection();
        var selectionNode = selection && selection.anchorNode && selection.anchorNode.parentElement;
        if (selection &&
            selectionNode &&
            event.currentTarget.contains(selectionNode)) {
            selection.empty();
        }
        setInitiated("touch");
        showTooltip();
    }, 
    // disabled since useRefCache for handlers
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [setInitiated, showTooltip]);
    return [
        stop,
        handleTouchStart,
        handleTouchMove,
        mode === "touch" ? handleContextMenu : onContextMenu,
    ];
}
//# sourceMappingURL=useHandlers.js.map