import { useCallback, useState } from "react";
import { getViewportSize, useRefCache } from "@react-md/utils";
var NOOP = function () { };
/**
 * A small hook that will set the tooltip position automatically based on the
 * container element's location within the viewport. However, if the `position`
 * option/prop was provided, that value will always be used instead.
 */
export default function usePosition(_a) {
    var determinedPosition = _a.position, defaultPosition = _a.defaultPosition, threshold = _a.threshold;
    var _b = useState(defaultPosition), position = _b[0], setPosition = _b[1];
    var prevPosition = useRefCache(position);
    /**
     * This will only be used when the `determinedPosition` is undefined. When the
     * container element starts the tooltip "visibility" mode, this will be called
     * so that we can best guess what the position of the tooltip should be based
     * on the current position of the container element within the viewport. If
     * this isn't done and the tooltip swaps position due to the positioning
     * logic, the animation will be reversed.
     */
    var setEstimatedPosition = useCallback(function (container) {
        var _a = container.getBoundingClientRect(), top = _a.top, left = _a.left;
        var nextPosition = defaultPosition;
        var vh = getViewportSize("height");
        var vw = getViewportSize("width");
        switch (defaultPosition) {
            case "above":
                if (top < vh - vh * threshold) {
                    nextPosition = "below";
                }
                break;
            case "below":
                if (top > vh * threshold) {
                    nextPosition = "above";
                }
                break;
            case "left":
                if (left < vw - vw * threshold) {
                    nextPosition = "right";
                }
                break;
            case "right":
                if (left > vw * threshold) {
                    nextPosition = "left";
                }
                break;
            // no default
        }
        if (prevPosition.current !== nextPosition) {
            setPosition(nextPosition);
        }
    }, 
    // disabled since useRefCache for prevPosition
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [defaultPosition, threshold]);
    if (typeof determinedPosition !== "undefined") {
        return {
            position: determinedPosition,
            setEstimatedPosition: NOOP,
        };
    }
    return {
        position: position,
        setEstimatedPosition: setEstimatedPosition,
    };
}
//# sourceMappingURL=usePosition.js.map