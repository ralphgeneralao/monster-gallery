var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React, { Children, cloneElement, useMemo, useRef, } from "react";
import cn from "classnames";
import { ConditionalPortal, } from "@react-md/portal";
import { useFixedPositioning } from "@react-md/transition";
import { unitToNumber, } from "@react-md/utils";
import { DEFAULT_TOOLTIP_DELAY, DEFAULT_TOOLTIP_THRESHOLD } from "./constants";
import Tooltip from "./Tooltip";
import useTooltipState from "./useTooltipState";
var MERGABLE_PROPS = [
    "onMouseEnter",
    "onMouseLeave",
    "onTouchStart",
    "onTouchMove",
    "onFocus",
    "onKeyDown",
    "onContextMenu",
];
/**
 * The `Tooltipped` component can be used to dynamically add a tooltip to child
 * element by cloning the required event handlers and accessibility props into
 * the child with `React.cloneChild`.
 */
function Tooltipped(_a) {
    var id = _a.id, children = _a.children, tooltipChildren = _a.tooltip, _b = _a.dense, dense = _b === void 0 ? false : _b, _c = _a.vhMargin, vhMargin = _c === void 0 ? 16 : _c, _d = _a.vwMargin, vwMargin = _d === void 0 ? 16 : _d, _e = _a.hoverDelay, hoverDelay = _e === void 0 ? DEFAULT_TOOLTIP_DELAY : _e, _f = _a.focusDelay, focusDelay = _f === void 0 ? DEFAULT_TOOLTIP_DELAY : _f, _g = _a.touchTimeout, touchTimeout = _g === void 0 ? DEFAULT_TOOLTIP_DELAY : _g, _h = _a.spacing, spacing = _h === void 0 ? "1.5rem" : _h, _j = _a.denseSpacing, denseSpacing = _j === void 0 ? "0.875rem" : _j, propPosition = _a.position, _k = _a.positionThreshold, positionThreshold = _k === void 0 ? DEFAULT_TOOLTIP_THRESHOLD : _k, _l = _a.portal, portal = _l === void 0 ? true : _l, portalInto = _a.portalInto, portalIntoId = _a.portalIntoId, onMouseEnter = _a.onMouseEnter, onMouseLeave = _a.onMouseLeave, onTouchStart = _a.onTouchStart, onTouchMove = _a.onTouchMove, onContextMenu = _a.onContextMenu, onFocus = _a.onFocus, onKeyDown = _a.onKeyDown, onShow = _a.onShow, onHide = _a.onHide, disableHoverMode = _a.disableHoverMode, describedBy = _a["aria-describedby"], _m = _a.defaultPosition, defaultPosition = _m === void 0 ? "below" : _m, disableSwapping = _a.disableSwapping, _o = _a.mountOnEnter, mountOnEnter = _o === void 0 ? true : _o, _p = _a.unmountOnExit, unmountOnExit = _p === void 0 ? true : _p, _q = _a.disableAutoSpacing, disableAutoSpacing = _q === void 0 ? process.env.NODE_ENV === "test" : _q, props = __rest(_a, ["id", "children", "tooltip", "dense", "vhMargin", "vwMargin", "hoverDelay", "focusDelay", "touchTimeout", "spacing", "denseSpacing", "position", "positionThreshold", "portal", "portalInto", "portalIntoId", "onMouseEnter", "onMouseLeave", "onTouchStart", "onTouchMove", "onContextMenu", "onFocus", "onKeyDown", "onShow", "onHide", "disableHoverMode", "aria-describedby", "defaultPosition", "disableSwapping", "mountOnEnter", "unmountOnExit", "disableAutoSpacing"]);
    var _r = useTooltipState({
        position: propPosition,
        disableHoverMode: disableHoverMode,
        defaultPosition: defaultPosition,
        positionThreshold: positionThreshold,
        hoverDelay: hoverDelay,
        focusDelay: focusDelay,
        touchTimeout: touchTimeout,
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
        onTouchStart: onTouchStart,
        onTouchMove: onTouchMove,
        onContextMenu: onContextMenu,
        onFocus: onFocus,
        onKeyDown: onKeyDown,
        onShow: onShow,
        onHide: onHide,
    }), hide = _r.hide, visible = _r.visible, position = _r.position, handlers = _r.handlers;
    var labelledBy = useRef(visible);
    var currentSpacing = useMemo(function () { return unitToNumber(dense ? denseSpacing : spacing); }, [spacing, denseSpacing, dense]);
    var getOptions;
    if (!disableAutoSpacing) {
        getOptions = function (node) {
            var spacing = unitToNumber(window.getComputedStyle(node).getPropertyValue("--rmd-tooltip-spacing"));
            return { xMargin: spacing, yMargin: spacing };
        };
    }
    var isHorizontal = position === "left" || position === "right";
    var _s = useFixedPositioning({
        anchor: {
            x: isHorizontal ? position : "center",
            y: isHorizontal ? "center" : position,
        },
        disableSwapping: typeof disableSwapping === "boolean" ? disableSwapping : !!propPosition,
        fixedTo: function () { return document.getElementById(id); },
        vhMargin: vhMargin,
        vwMargin: vwMargin,
        yMargin: currentSpacing,
        xMargin: currentSpacing,
        onResize: hide,
        onScroll: hide,
        getOptions: getOptions,
    }), style = _s.style, onEnter = _s.onEnter, onEntering = _s.onEntering, onEntered = _s.onEntered, onExited = _s.onExited;
    if (!tooltipChildren) {
        if (typeof children === "function") {
            return children({ id: id, tooltip: null, "aria-describedby": describedBy });
        }
        var child_1 = Children.only(children);
        return cloneElement(child_1, { id: id, "aria-describedby": describedBy });
    }
    var tooltipId = props.tooltipId;
    if (!tooltipId) {
        tooltipId = id + "-tooltip";
    }
    var tooltip = (React.createElement(ConditionalPortal, { portal: portal, portalInto: portalInto, portalIntoId: portalIntoId },
        React.createElement(Tooltip, __assign({ id: tooltipId }, props, { dense: dense, position: position, mountOnEnter: mountOnEnter, unmountOnExit: unmountOnExit, style: style, onEnter: function (node, appear) {
                if (onEnter) {
                    onEnter(node, appear);
                }
                labelledBy.current = true;
            }, onEntering: onEntering, onEntered: onEntered, onExited: function (node) {
                if (onExited) {
                    onExited(node);
                }
                labelledBy.current = false;
            }, visible: visible }), tooltipChildren)));
    var config = __assign({ id: id, "aria-describedby": cn(labelledBy.current && tooltipId, describedBy) || undefined }, handlers);
    if (typeof children === "function") {
        return children(__assign(__assign({}, config), { tooltip: tooltip }));
    }
    var child = Children.only(children);
    var merged = MERGABLE_PROPS.reduce(function (result, propName) {
        var propHandler = child.props[propName];
        var configHandler = config[propName];
        if (!propHandler) {
            result[propName] = configHandler;
        }
        else if (!configHandler) {
            result[propName] = propHandler;
        }
        else {
            // not sure of a way to actually strongly type this nicely.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            result[propName] = function (event) {
                propHandler(event);
                configHandler(event);
            };
        }
        return result;
    }, __assign({}, config));
    return (React.createElement(React.Fragment, null,
        cloneElement(child, merged),
        tooltip));
}
if (process.env.NODE_ENV !== "production") {
    try {
        var PropTypes = require("prop-types");
        Tooltipped.propTypes = {
            tooltipId: PropTypes.string,
            dense: PropTypes.bool,
            spacing: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
            denseSpacing: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
            positionThreshold: PropTypes.number,
            disableAutoSpacing: PropTypes.bool,
            vwMargin: PropTypes.number,
            vhMargin: PropTypes.number,
            portal: PropTypes.bool,
            lineWrap: PropTypes.bool,
            focusDelay: PropTypes.number,
            hoverDelay: PropTypes.number,
            touchTimeout: PropTypes.number,
            mountOnEnter: PropTypes.bool,
            unmountOnExit: PropTypes.bool,
            defaultPosition: PropTypes.oneOf(["above", "below", "left", "right"]),
        };
    }
    catch (e) { }
}
export default Tooltipped;
//# sourceMappingURL=Tooltipped.js.map