var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
import { useCallback, useEffect, useReducer, useRef } from "react";
import { useTimeout, useToggle } from "@react-md/utils";
import { DEFAULT_MESSAGE_QUEUE_TIMEOUT, } from "./MessageQueueContext";
import useWindowBlurPause from "./useWindowBlurPause";
export var ADD_MESSAGE = "ADD_MESSAGE";
export var POP_MESSAGE = "POP_MESSAGE";
export var RESET_QUEUE = "RESET_QUEUE";
/**
 * @private
 */
export function addMessage(message, duplicates) {
    return { type: ADD_MESSAGE, message: message, duplicates: duplicates };
}
/**
 * @private
 */
export var popMessage = function () { return ({ type: POP_MESSAGE }); };
/**
 * @private
 */
export var resetQueue = function () { return ({ type: RESET_QUEUE }); };
/**
 * This function is used to update the message queue state by adding a new message when
 * needed.
 *
 * @private
 */
export function handleAddMessage(state, message, duplicates) {
    if (state.length === 0) {
        return [message];
    }
    var messageId = message.messageId, _a = message.messagePriority, messagePriority = _a === void 0 ? "normal" : _a;
    var i = state.findIndex(function (mes) { return mes.messageId === messageId; });
    var isNext = messagePriority === "next";
    var isNormal = messagePriority === "normal";
    var isReplace = messagePriority === "replace";
    var isImmediate = messagePriority === "immediate";
    var isDuplicable = duplicates === "allow";
    var isRestart = duplicates === "restart";
    if (isNext || isImmediate) {
        var nextState = state.slice();
        // remove the existing message if duplicated messages aren't allowed. This will
        // kind of act like a replace + next behavior
        if (!isDuplicable && i > 0) {
            nextState.splice(i, 1);
        }
        var current = nextState[0], remaining = nextState.slice(1);
        if (isImmediate && current.messagePriority !== "immediate") {
            return __spreadArrays([current, message, current], remaining);
        }
        return __spreadArrays([current, message], remaining);
    }
    if (i === -1 || (isDuplicable && isNormal)) {
        return __spreadArrays(state, [message]);
    }
    if (isNormal) {
        if (isRestart) {
            // creating a new state so that the queue visibility hook can still be triggered
            // which will restart the timer
            return state.slice();
        }
        return state;
    }
    if (isReplace) {
        var nextState = state.slice();
        nextState[i] = message;
        return nextState;
    }
    return __spreadArrays(state, [message]);
}
/**
 * @private
 */
export function reducer(state, action) {
    switch (action.type) {
        case ADD_MESSAGE:
            return handleAddMessage(state, action.message, action.duplicates);
        case POP_MESSAGE:
            return state.length ? state.slice(1) : state;
        case RESET_QUEUE:
            return state.length ? [] : state;
        default:
            return state;
    }
}
/**
 * This is the main logic for the message queue behavior that will handle:
 *
 * - creating timeouts as needed to show/hide toasts within the SnackbarQueue component
 * - create a way to push messages with optional priority onto the queue
 *
 * @private
 */
export default function useMessageQueue(_a) {
    var _b = _a.timeout, timeout = _b === void 0 ? DEFAULT_MESSAGE_QUEUE_TIMEOUT : _b, _c = _a.duplicates, duplicates = _c === void 0 ? "allow" : _c, _d = _a.defaultQueue, defaultQueue = _d === void 0 ? [] : _d;
    var _e = useReducer(function (state, action) { return reducer(state, action); }, defaultQueue), queue = _e[0], dispatch = _e[1];
    var queueRef = useRef(queue);
    var addMessageDispatch = useCallback(function (message) {
        if (duplicates !== "allow" && !message.messageId) {
            throw new Error("A messageId is required when the \"" + duplicates + "\" duplicate behavior is enabled but it was not provided in the current message.");
        }
        dispatch({ type: ADD_MESSAGE, message: message, duplicates: duplicates });
    }, [duplicates]);
    var popMessageDispatch = useCallback(function () {
        dispatch(popMessage());
    }, []);
    var resetQueueDispatch = useCallback(function () {
        dispatch(resetQueue());
        return queueRef.current;
    }, []);
    var _f = useToggle(defaultQueue.length > 0), visible = _f[0], showMessage = _f[1], hideMessage = _f[2];
    var _g = useTimeout(hideMessage, timeout), startTimer = _g[0], stopTimer = _g[1], restartTimer = _g[2];
    useEffect(function () {
        // this effect will handle all the "logic" for transitioning between each message along with the
        // message priority updates.
        var message = queue[0], nextMessage = queue[1];
        if (!message) {
            return;
        }
        var prevQueue = queueRef.current;
        var prevMessage = prevQueue[0];
        if (message.messagePriority !== "immediate" &&
            nextMessage &&
            nextMessage.messagePriority === "immediate") {
            stopTimer();
            if (!visible) {
                popMessageDispatch();
                return;
            }
            hideMessage();
            return;
        }
        if (!visible) {
            showMessage();
        }
        if (queue.length === prevQueue.length && message === prevMessage) {
            restartTimer();
        }
        // only want to run this on queue changes
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [queue]);
    useWindowBlurPause({
        startTimer: startTimer,
        stopTimer: stopTimer,
        visible: visible,
        message: queue[0],
    });
    useEffect(function () {
        queueRef.current = queue;
    });
    return {
        queue: queue,
        resetQueue: resetQueueDispatch,
        visible: visible,
        hideMessage: hideMessage,
        addMessage: addMessageDispatch,
        popMessage: popMessageDispatch,
        startTimer: startTimer,
        stopTimer: stopTimer,
        restartTimer: restartTimer,
    };
}
//# sourceMappingURL=useMessageQueue.js.map